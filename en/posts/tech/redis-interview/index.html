<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Redis Interview | Younger&#39;s Blog</title>
<meta name="keywords" content="redis, interview">
<meta name="description" content="1. 持久化怎么实现的 aof：append only file。持续写文件到buffer ring中，然后根据参数完成fsync操作。aof文件会有重写操作">
<meta name="author" content="Younger">
<link rel="canonical" href="https://www.youngergo.cn/en/posts/tech/redis-interview/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://youngergo.cn/images/life/me/avatar.jpg">
<link rel="icon" type="image/png" sizes="16x16" href="https://youngergo.cn/images/life/me/avatar.jpg">
<link rel="icon" type="image/png" sizes="32x32" href="https://youngergo.cn/images/life/me/avatar.jpg">
<link rel="apple-touch-icon" href="https://youngergo.cn/images/life/me/avatar.jpg">
<link rel="mask-icon" href="https://youngergo.cn/images/life/me/avatar.jpg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Redis Interview" />
<meta property="og:description" content="1. 持久化怎么实现的 aof：append only file。持续写文件到buffer ring中，然后根据参数完成fsync操作。aof文件会有重写操作" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.youngergo.cn/en/posts/tech/redis-interview/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-02T19:07:39+08:00" />
<meta property="article:modified_time" content="2023-08-02T19:07:39+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Redis Interview"/>
<meta name="twitter:description" content="1. 持久化怎么实现的 aof：append only file。持续写文件到buffer ring中，然后根据参数完成fsync操作。aof文件会有重写操作"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚文章",
      "item": "https://www.youngergo.cn/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "👨🏻‍💻 技术",
      "item": "https://www.youngergo.cn/en/posts/tech/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Redis Interview",
      "item": "https://www.youngergo.cn/en/posts/tech/redis-interview/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis Interview",
  "name": "Redis Interview",
  "description": "1. 持久化怎么实现的 aof：append only file。持续写文件到buffer ring中，然后根据参数完成fsync操作。aof文件会有重写操作",
  "keywords": [
    "redis", "interview"
  ],
  "articleBody": "1. 持久化怎么实现的 aof：append only file。持续写文件到buffer ring中，然后根据参数完成fsync操作。aof文件会有重写操作，节省空间，以及宕机恢复操作的时间。 rdb：内存快照。对某一时刻的redis的数据情况进行快照存储。 2. zset怎么做延迟队列 zadd key Val score：job数据存储在Val，score代表任务执行时间。 zrangebyscore time，拿当前的时间戳做比较。取可执行的任务。 zremrange 移除这些任务。\n3. 哪些操作会触发Redis单线程处理IO请求性能瓶颈。 耗时的操作包括：\n操作bigkey：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时\n使用复杂度过高的命令：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据\n大量key集中过期：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长\n淘汰策略：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会 造成耗时变长。\nAOF刷盘开启always机制：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能\n主从全量同步生成RDB：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久\nRedis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能。当然，只针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的\n4. redis分布式锁用过吗？说下咋用的，哪些场景需要用 1 SET lock_key unique_Val NX PX 10000 lock_key 就是 key 键； unique_Val 是客户端生成的唯一的标识，区分来自不同客户端的锁操作； NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作； PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。 解锁时因为要判断是否是加锁者来解锁，需要完成判断和解锁两个操作。故借助lua脚本完成。\n难点：\n超时时间不好设置。设置短了，任务还未执行完成，其他的线程就可以拿到锁。设置长了，影响性能。为了解决这个问题可以加一个看门狗机制。也就是新增一个守护线程专门监控这种情况。当任务未执行完成，锁快要过期时，续约锁时间。当任务执行完成，但锁还未过期，直接销毁锁即可 主从模式的时候，redis异步复制数据，这将导致分布式锁的不可靠性。如果在主节点获取锁后，其他节点还未同步到锁。主节点宕机了。那么新的主节点还是可以获取到锁。那么如何解决呢。就是redis的redlock红锁 Redis的redlock\n为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock（红锁）。\n它是基于多个 Redis 节点的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。\nRedlock 算法的基本思路，是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。\n这样一来，即使有某个 Redis 节点发生故障，因为锁的数据在其他节点上也有保存，所以客户端仍然可以正常地进行锁操作，锁的数据也不会丢失。\nRedlock 算法加锁三个过程：\n第一步是，客户端获取当前时间（t1）。 第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作： 加锁操作使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。 如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。 第三步是，一旦客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 \u003c 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。 可以看到，加锁成功要同时满足两个条件（简述：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功）：\n条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁； 条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。 加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。\n加锁失败后，客户端向所有 Redis 节点发起释放锁的操作，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。\n5. 缓存穿透、雪崩的解决方案 缓存穿透：同一时刻大量请求访问不存在的数据。\n缓存空值：可以在缓存中缓存空值来防止压力给到mysql。但是这也不是万能的。缓存空值会浪费我们的空间，如果缓存的空值比较多。还会影响redis的命中率。淘汰了我们正常的热点数据。所以生产环境，我们需要监控一些null空值的数量。避免浪费空间和对正常热数据的影响。我们还可以使用布隆过滤器来处理。 布隆过滤器：查询布隆过滤器，判断数据是否存在。 用法：存储数据时，布隆过滤器会先以hash函数来判断数据的落位bit，以bit位0,1来标示数据是否存在。读取数据时，就可以根据0，1判断是否数据是否存在，而不用去缓存和数据库查找数据。 缺点：1.有hash函数就有hash碰撞，所以就有可能将并不在集合中的元素判断在里面。2.不支持删除元素 解决方案：针对第一点，可以采用多个hash函数来确定bit位，减少误差。多个hash都是1的时候，数据真正存在。(存在疑问？多个hash函数不是更加加大了碰撞的几率嘛。确实是这样的。但是前期数据量比较少的时候，多个hash函数可以显著增加误判率，但是随着越来越多的“1”被占用。碰撞的几率也会越来越大。所以需要去关注布隆过滤器的负载量) 另外布隆过滤器有误判的可能。布隆过滤器判断存在数据存在时，不一定存在(因为hash碰撞占位)。数据不存在时，肯定是不存在，这个是准确的。 缓存雪崩：有大量的key在同一时间过期，或者redis故障\n分散key的失效时间。设置过期时间时，可以加一个时间偏移量 设置key不过期。这个方式比较暴力。但是key并不是真正的会一直存在。redis的多种内存淘汰机制可能会清理掉数据。因此我们需要其他的机制来监控缓存的数据。 可以将缓存更新的任务交由后台线程完成。定时扫描key是否存在。是否需要更新最新数据。业务不负责缓存数据的更新。但是定时扫描的定时需要trade-off，均衡业务的容忍度。 业务请求时发现数据不存在，往mq中写一条消息。交由消费者完成数据的更新和加载。当然执行前可以检测下，数据是否已经存在。 互斥锁。保证不会有大量的请求打到mysql。只有一个请求完成cache aside方式的数据回写。 缓存击穿：热点key数据过期\n互斥锁 任务key不过期 6. 如何保证缓存-db一致性 cache aside方式。选择先更新db，再删除缓存。另外可加消费mysql binlog 的方式或者后台任务。保证更新db和删除操作都执行成功。 7. redis怎么做限流 可以依赖redis单线程和其支持的数据结构完成限流操作。例如：依赖list结构实现令牌桶，固定时间生成token，当令牌token为空时，新来的请求阻塞或者直接返回失败。下面是go-zero框架lua脚本实现令牌桶的方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 script = `local rate = tonumber(ARGV[1]) local capacity = tonumber(ARGV[2]) local now = tonumber(ARGV[3]) local requested = tonumber(ARGV[4]) //过期到下次填充前的时间 local fill_time = capacity/rate local ttl = math.floor(fill_time*2) local last_tokens = tonumber(redis.call(\"get\", KEYS[1])) if last_tokens == nil then last_tokens = capacity end local last_refreshed = tonumber(redis.call(\"get\", KEYS[2])) if last_refreshed == nil then last_refreshed = 0 end //计算上次更新token的时间差，计算出需要补多少token。判断是否满足请求需要的request //计算剩余的token量 local delta = math.max(0, now-last_refreshed) local filled_tokens = math.min(capacity, last_tokens+(delta*rate)) local allowed = filled_tokens \u003e= requested local new_tokens = filled_tokens if allowed then new_tokens = filled_tokens - requested end redis.call(\"setex\", KEYS[1], ttl, new_tokens) redis.call(\"setex\", KEYS[2], ttl, now) return allowed` 8. redis中server和client通信方式？ 简单文本通信协议 9. redis淘汰策略 noeviction（不淘汰策略）：当内存不足以容纳新写入数据时，新写入操作会报错\"OOM（Out of Memory）\"。默认情况下，Redis就采用了此种淘汰策略。 allkeys-lru（最近最少使用淘汰策略）：Redis会根据键的最近最少使用时间来淘汰数据。当内存不足以容纳新写入数据时，从所有键中选择最近最少使用的数据淘汰。 volatile-lru（设置过期时间的最近最少使用淘汰策略）：Redis会根据键的最近最少使用时间来淘汰键值对，但只会针对设定了过期时间的键值对进行淘汰。 volatile-ttl（设置过期时间淘汰策略）：Redis会根据键值对的剩余存活时间来淘汰数据。当内存不足以容纳新写入数据时，优先淘汰存活时间较短的数据。此种淘汰策略适用于只关心最近活跃数据的场景。 10. 缓存预热？如何做？ 缓存预热：redis启动前缓存热门数据 nginx+lua将流量请求打到kafka中，让kafka抗高并发的量。然后数据写入storm中，storm完成M份Top N数据的生成。然后聚合生成热门数据存到zk中，新起任务完成读取数据，写入redis。完成预热缓存。 11. Redis 应用题: 设计一个每日日活用户统计功能 需求: 我们的网站每天用户访问之后，UserID 将会被收集到我们的 Redis 数据存储（需要你思考如何存储），我们的后台需要支持一个功能: 1.API - 支持查询 某一天访问的用户 \u0026 前一天并没有访问我们的网站 Request : {\"date\": \"20230216\"} Response: {\"user_ids\": [1,3,4]} 2.API 拓展 - 在支持(1) 的基础上，支持根据指定批量日期范围查询这个数据 Request : {\"dates\": [\"20230216\", \"20230217\"]} Response: {\"list\": [{\"date\": \"20230216\", \"user_ids\": [1,3,4]}, {\"date\": \"20230216\", \"user_ids\": [2,9]}]} 数据量级: Level0: 每日访问用户数在 1K 以内 Level1: 每日访问用户数在 10K 以内 考察点1: redis 数据存储如何设计，应该使用什么数据结构，怎么记录和实现功能 答案： 1.按照天的维度将用户放到set结构中(key是日期，value是UserID)，针对查询需求，可以将两天的set做diff操作，生成到一个new set中。 2.如果要支持指定批量日期范围查询，首先需要明确最早日期，日期数量是否有限制？qps是多少(每条执行多少请求和计算量有关)，如果不高的话，可以实时diff计算， 一般情况下，latency会比较长。 latency过长的解决方案： 1.缓存：new set已经放入到了redis中，如果请求中的日期过多，影响了latency的性能，那么可以使用进程内缓存，此时就要考虑缓存的大小如何设计？(设计的标准应该是满足当前qps，多少数据从redis拿，多少从进程缓存拿，可以满足qps需求)，考虑设计缓存淘汰方式(LRU、LFU or 其他？，这里选择LFU，淘汰使用频率最少的比较合理)。 2.升级机器配置，升级cpu配置，升级redis配置。使得机器cpu不是瓶颈(内存应该不是瓶颈，不需要考虑)，升级redis的cpu配置，主从或者分片。 数量级问题需要注意的点：1k以内的set，userid是int类型的话8byte，一个日期的key存储占8k(set是hash结构和intset，那就按照正常的数组大小评估，就是8k)，不算是大key(大key的标准和结构中的数量和元素的大小相关)，那么diff完成的也不是大key。这个时候就还是考虑latency的问题了，按照上面方案解决就行。 如果真的数量级到了大key，那么一般方案也就是拆分成多个key，此时内存友好，但是cpu就不友好了。解决的话，可以升级配置。或者redis集群部署，分散压力。 12. Redis的主从同步流程 全量同步： 触发条件：首次同步，master节点进程id发生变化，master缓存中没有slave当前同步的offsetID(滞后太多) 同步过程： slave向master发起链接建立。 slave向master发起sync命令，请求复制数据 master收到PSYNC命令后，会在后台进行数据持久化； 通过bgsave生成最新的rdb快照文件 bgsave期间，将客户端发送的命令（会修改数据集的）缓存到内存中； 持久化完毕后，master将这份RDB数据发送给slave； slave会把接收到的数据进行持久化生成RDB，然后再加载到内存中。 master继续将之前缓存在内存中的命令通过socket发送给slave。 增量，断点续传同步： 同步过程： 断开重连后，slave向master发送psync命令同步数据 master会在内存中维护命令队列repl backlong buff，并且master拥有各slave的数据下标offset，slave有master进程id 重连后，从下标开始接受master缓冲队列的命令，完成同步 如果master进程节点id变化，或者从节点数据下标offset太久，已经不在master的缓存队列里，则会进行一次全量数据复制 注意点：\n主从复制时，如果有过多的从节点，为了缓解主从复制风暴，多个从节点同事复制主节点导致主节点压力过大。可以让部分从节点作为假主，关联其他从库。也就是主-从(假主)-从 RDB用于全量复制，全量复制完后，后续的执行指令，master会将repl backlong buff中缓存的指令通过socket发送给从库。 主从复制的时候，针对slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己当前的数据。slave-lazy-flush参数设置决定是否采用异步flush的机制。异步flush清空从节点本地数据库，可减少全量同步耗时，从而减少主库因输出缓冲区爆炸引起的内存使用增长。 13. Redis多线程网络IO模型(下面的内容都来自潘少的blog) redis为什么这么快？ C语言支持 内存型数据库 网络IO多路复用 单线程模型，避免多线程频繁上下文切换，额外的同步机制 高性能的数据结构设计 redis为什么选择单线程 避免过多的上下文切换开销 多线程调度必然会有上下文切换的开销，具体的开销在于程序计数器，堆栈指针和程序状态等一系列寄存器置换，程序堆栈重置等，还会影响cpu cache，TLB快表的淘汰置换。单一进程的多线程切换还好一些，因为多个线程共享进程地址空间。对比跨进程(多进程)的调度，那么开销就会很大，需要切换掉整个进程的地址空间。 避免同步机制的开销 多线程模型下，势必会有一些同步机制，用来保证数据的状态。简单来说就是需要加锁了。因为redis有丰富的数据类型，此时锁的粒度又会有很多取舍。这样不仅会有锁的开销，程序的复杂度也会极具增长。与redis简单设计的理念不符 redis多线程发展历程 redis 4.0的时候引入了多线程处理异步任务。这些任务包括数据清理，数据备份bgsave等。主要的目的避免一些阻塞的命令，影响单线程执行模型。比如新增了UNLINK、FLUSHALL ASYNC等。但网络IO处理还是单线程的。 redis 6.0。 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis（6.0之前 ） 采用的是单 Reactor 单进程的方案。 发展到这个阶段，多线程来提升整体性能已经是必定的路了。因为redis的单线程模型会导致系统消耗很多cpu在网络IO上，从而降低了吞吐量，那么为了解决这个问题，只能1.优化网络IO 2.提高机器内存读写速度。显然完成条件1是首先考虑的。优化1是手段有1.零拷贝 2.利用多核优势。零拷贝无法应对redis这一类复杂的网络IO场景。所以顺理成章的我们需要利用多核优势了。 6.0的时候，增加多线程来处理网络IO的读写，就是多线程去处理IO读写数据，但执行操作还是单线程的。官方的数据显示增加多线程后，性能提升一倍。 cpu亲和性 redis6.0后，多线程执行很多异步任务，并发度已经有很大提升，而且redis是对吞吐量和延迟很敏感的系统。故此需要考虑cpu切换时的性能损耗，为了避免这个情况，redis启动的时候设置了cpu亲和性，也就是绑核，将某些线程/进程绑定到固定的cpu上，其他任务就不会占用这些任务的cpu时间片，能更高效率的工作，也能极大限度借助cpu cache提升性能。 free lock的设计 引入多线程，不可避免的会有共享资源竞争，就会引出锁来保护共享资源。但是redis通过原子操作和时空交错访问来实现无锁的多线程模型。记住redis6.0的源码中，IO读写多线程只完成读写数据的操作。 下面是多线程读的流程。 当有client就绪时，就会将client放入队列clients_pending_read 主线程遍历待读取的client队列，通过 RR 策略把所有任务分配给 I/O 线程和主线程去读取和解析客户端命令。 忙轮询等待所有 I/O 线程完成任务。 完成任务后，再遍历 clients_pending_read，执行所有 client 的命令。 执行完成后，需要回复的内容已经写入每个client的buf中了。然后将client放入clients_pending_write队列中，等待调度，将响应内容返回给客户端。 下面是多线程写的流程： 检查当前任务负载，如果当前的任务数量不足以用多线程模式处理的话，则休眠 I/O 线程并且直接同步将响应数据回写到客户端。 唤醒正在休眠的 I/O 线程（如果有的话）。 遍历待写出的 client 队列 clients_pending_write，通过 RR 策略把所有任务分配给 I/O 线程和主线程去将响应数据写回到客户端。 忙轮询等待所有 I/O 线程完成任务。 最后再遍历 clients_pending_write，为那些还残留有响应数据的 client 注册命令回复处理器 sendReplyToClient，等待客户端可写之后在事件循环中继续回写残余的响应数据。 为什么是lock free呢？ 主线程和 I/O 线程之间共享的变量有三个：io_threads_pending 计数器、io_threads_op I/O 标识符和 io_threads_list 线程本地任务队列。io_threads_pending 是原子变量，不需要加锁保护，io_threads_op 和 io_threads_list 这两个变量则是通过控制主线程和 I/O 线程交错访问来规避共享数据竞争问题：I/O 线程启动之后会通过忙轮询和锁休眠等待主线程的信号，在这之前它不会去访问自己的本地任务队列 io_threads_list[id]，而主线程会在分配完所有任务到各个 I/O 线程的本地队列之后才去唤醒 I/O 线程开始工作，并且主线程之后在 I/O 线程运行期间只会访问自己的本地任务队列 io_threads_list[0] 而不会再去访问 I/O 线程的本地队列，这也就保证了主线程永远会在 I/O 线程之前访问 io_threads_list 并且之后不再访问，保证了交错访问。io_threads_op 同理，主线程会在唤醒 I/O 线程之前先设置好 io_threads_op 的值，并且在 I/O 线程运行期间不会再去访问这个变量。 ",
  "wordCount" : "7795",
  "inLanguage": "en",
  "datePublished": "2023-08-02T19:07:39+08:00",
  "dateModified": "2023-08-02T19:07:39+08:00",
  "author":[{
    "@type": "Person",
    "name": "Younger"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.youngergo.cn/en/posts/tech/redis-interview/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Younger's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://youngergo.cn/images/life/me/avatar.jpg"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.youngergo.cn/en/" accesskey="h" title="Younger&#39;s Blog (Alt + H)">
                <img src="https://youngergo.cn/images/life/me/avatar.jpg" alt="" aria-label="logo"
                    height="35">Younger&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.youngergo.cn/en/search" title="🔍搜索">
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://www.youngergo.cn/en/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://www.youngergo.cn/en/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://www.youngergo.cn/en/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://www.youngergo.cn/en/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://www.youngergo.cn/en/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://www.youngergo.cn/en/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.youngergo.cn/en/">Home</a>&nbsp;»&nbsp;<a href="https://www.youngergo.cn/en/posts/">📚文章</a>&nbsp;»&nbsp;<a href="https://www.youngergo.cn/en/posts/tech/">👨🏻‍💻 技术</a></div>
    <h1 class="post-title">
      Redis Interview
    </h1>
    <div class="post-meta"><span title='2023-08-02 19:07:39 +0800 CST'>2023-08-02</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;Younger

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e6%8c%81%e4%b9%85%e5%8c%96%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="1. 持久化怎么实现的">1. 持久化怎么实现的</a></li>
                <li>
                    <a href="#2-zset%e6%80%8e%e4%b9%88%e5%81%9a%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97" aria-label="2. zset怎么做延迟队列">2. zset怎么做延迟队列</a></li>
                <li>
                    <a href="#3-%e5%93%aa%e4%ba%9b%e6%93%8d%e4%bd%9c%e4%bc%9a%e8%a7%a6%e5%8f%91redis%e5%8d%95%e7%ba%bf%e7%a8%8b%e5%a4%84%e7%90%86io%e8%af%b7%e6%b1%82%e6%80%a7%e8%83%bd%e7%93%b6%e9%a2%88" aria-label="3. 哪些操作会触发Redis单线程处理IO请求性能瓶颈。">3. 哪些操作会触发Redis单线程处理IO请求性能瓶颈。</a></li>
                <li>
                    <a href="#4-redis%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e7%94%a8%e8%bf%87%e5%90%97%e8%af%b4%e4%b8%8b%e5%92%8b%e7%94%a8%e7%9a%84%e5%93%aa%e4%ba%9b%e5%9c%ba%e6%99%af%e9%9c%80%e8%a6%81%e7%94%a8" aria-label="4. redis分布式锁用过吗？说下咋用的，哪些场景需要用">4. redis分布式锁用过吗？说下咋用的，哪些场景需要用</a></li>
                <li>
                    <a href="#5-%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e9%9b%aa%e5%b4%a9%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="5. 缓存穿透、雪崩的解决方案">5. 缓存穿透、雪崩的解决方案</a></li>
                <li>
                    <a href="#6-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%bc%93%e5%ad%98-db%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="6. 如何保证缓存-db一致性">6. 如何保证缓存-db一致性</a></li>
                <li>
                    <a href="#7-redis%e6%80%8e%e4%b9%88%e5%81%9a%e9%99%90%e6%b5%81" aria-label="7. redis怎么做限流">7. redis怎么做限流</a></li>
                <li>
                    <a href="#8-redis%e4%b8%adserver%e5%92%8cclient%e9%80%9a%e4%bf%a1%e6%96%b9%e5%bc%8f" aria-label="8. redis中server和client通信方式？">8. redis中server和client通信方式？</a></li>
                <li>
                    <a href="#9-redis%e6%b7%98%e6%b1%b0%e7%ad%96%e7%95%a5" aria-label="9. redis淘汰策略">9. redis淘汰策略</a></li>
                <li>
                    <a href="#10-%e7%bc%93%e5%ad%98%e9%a2%84%e7%83%ad%e5%a6%82%e4%bd%95%e5%81%9a" aria-label="10. 缓存预热？如何做？">10. 缓存预热？如何做？</a></li>
                <li>
                    <a href="#11-redis-%e5%ba%94%e7%94%a8%e9%a2%98-%e8%ae%be%e8%ae%a1%e4%b8%80%e4%b8%aa%e6%af%8f%e6%97%a5%e6%97%a5%e6%b4%bb%e7%94%a8%e6%88%b7%e7%bb%9f%e8%ae%a1%e5%8a%9f%e8%83%bd" aria-label="11. Redis 应用题: 设计一个每日日活用户统计功能">11. Redis 应用题: 设计一个每日日活用户统计功能</a></li>
                <li>
                    <a href="#12-redis%e7%9a%84%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e6%b5%81%e7%a8%8b" aria-label="12. Redis的主从同步流程">12. Redis的主从同步流程</a></li>
                <li>
                    <a href="#13-redis%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%bd%91%e7%bb%9cio%e6%a8%a1%e5%9e%8b%e4%b8%8b%e9%9d%a2%e7%9a%84%e5%86%85%e5%ae%b9%e9%83%bd%e6%9d%a5%e8%87%aa%e6%bd%98%e5%b0%91%e7%9a%84bloghttpsstrikefreedomtoparchivesmultiple-threaded-network-model-in-redis" aria-label="13. Redis多线程网络IO模型(下面的内容都来自潘少的blog)">13. Redis多线程网络IO模型(下面的内容都来自潘少的<a href="https://strikefreedom.top/archives/multiple-threaded-network-model-in-redis">blog</a>)</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h3 id="1-持久化怎么实现的">1. 持久化怎么实现的<a hidden class="anchor" aria-hidden="true" href="#1-持久化怎么实现的">#</a></h3>
<ul>
<li>aof：append only file。持续写文件到buffer ring中，然后根据参数完成fsync操作。aof文件会有重写操作，节省空间，以及宕机恢复操作的时间。</li>
<li>rdb：内存快照。对某一时刻的redis的数据情况进行快照存储。</li>
</ul>
<h3 id="2-zset怎么做延迟队列">2. zset怎么做延迟队列<a hidden class="anchor" aria-hidden="true" href="#2-zset怎么做延迟队列">#</a></h3>
<p>zadd key Val score：job数据存储在Val，score代表任务执行时间。
zrangebyscore time，拿当前的时间戳做比较。取可执行的任务。
zremrange 移除这些任务。</p>
<h3 id="3-哪些操作会触发redis单线程处理io请求性能瓶颈">3. 哪些操作会触发Redis单线程处理IO请求性能瓶颈。<a hidden class="anchor" aria-hidden="true" href="#3-哪些操作会触发redis单线程处理io请求性能瓶颈">#</a></h3>
<p>耗时的操作包括：</p>
<ul>
<li>
<p><strong>操作bigkey</strong>：写入一个bigkey在分配内存时需要消耗更多的时间，同样，删除bigkey释放内存同样会产生耗时</p>
</li>
<li>
<p><strong>使用复杂度过高的命令</strong>：例如SORT/SUNION/ZUNIONSTORE，或者O(N)命令，但是N很大，例如lrange key 0 -1一次查询全量数据</p>
</li>
<li>
<p><strong>大量key集中过期</strong>：Redis的过期机制也是在主线程中执行的，大量key集中过期会导致处理一个请求时，耗时都在删除过期key，耗时变长</p>
</li>
<li>
<p><strong>淘汰策略</strong>：淘汰策略也是在主线程执行的，当内存超过Redis内存上限后，每次写入都需要淘汰一些key，也会 造成耗时变长。</p>
</li>
<li>
<p><strong>AOF刷盘开启always机制</strong>：每次写入都需要把这个操作刷到磁盘，写磁盘的速度远比写内存慢，会拖慢Redis的性能</p>
</li>
<li>
<p><strong>主从全量同步生成RDB</strong>：虽然采用fork子进程生成数据快照，但fork这一瞬间也是会阻塞整个线程的，实例越大，阻塞时间越久</p>
</li>
<li>
<p>Redis在6.0推出了多线程，可以在高并发场景下利用CPU多核多线程读写客户端数据，进一步提升server性能。当然，只针对客户端的读写是并行的，每个命令的真正操作依旧是单线程的</p>
</li>
</ul>
<h3 id="4-redis分布式锁用过吗说下咋用的哪些场景需要用">4. redis分布式锁用过吗？说下咋用的，哪些场景需要用<a hidden class="anchor" aria-hidden="true" href="#4-redis分布式锁用过吗说下咋用的哪些场景需要用">#</a></h3>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>SET lock_key unique_Val NX PX <span style="color:#ae81ff">10000</span> 
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>lock_key 就是 key 键；</li>
<li>unique_Val 是客户端生成的唯一的标识，区分来自不同客户端的锁操作；</li>
<li>NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；</li>
<li>PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。</li>
</ul>
<p>解锁时因为要判断是否是加锁者来解锁，需要完成判断和解锁两个操作。故借助lua脚本完成。</p>
<p>难点：</p>
<ol>
<li>超时时间不好设置。设置短了，任务还未执行完成，其他的线程就可以拿到锁。设置长了，影响性能。为了解决这个问题可以加一个看门狗机制。也就是新增一个守护线程专门监控这种情况。当任务未执行完成，锁快要过期时，续约锁时间。当任务执行完成，但锁还未过期，直接销毁锁即可</li>
<li>主从模式的时候，redis异步复制数据，这将导致分布式锁的不可靠性。如果在主节点获取锁后，其他节点还未同步到锁。主节点宕机了。那么新的主节点还是可以获取到锁。那么如何解决呢。就是redis的redlock红锁</li>
</ol>
<p><em><strong>Redis的redlock</strong></em></p>
<p>为了保证集群环境下分布式锁的可靠性，Redis 官方已经设计了一个分布式锁算法 Redlock（红锁）。</p>
<p>它是基于<strong>多个 Redis 节点</strong>的分布式锁，即使有节点发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。官方推荐是至少部署 5 个 Redis 节点，而且都是主节点，它们之间没有任何关系，都是一个个孤立的节点。</p>
<p>Redlock 算法的基本思路，<strong>是让客户端和多个独立的 Redis 节点依次请求申请加锁，如果客户端能够和半数以上的节点成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败</strong>。</p>
<p>这样一来，即使有某个 Redis 节点发生故障，因为锁的数据在其他节点上也有保存，所以客户端仍然可以正常地进行锁操作，锁的数据也不会丢失。</p>
<p>Redlock 算法加锁三个过程：</p>
<ul>
<li>第一步是，客户端获取当前时间（t1）。</li>
<li>第二步是，客户端按顺序依次向 N 个 Redis 节点执行加锁操作：
<ul>
<li>加锁操作使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。</li>
<li>如果某个 Redis 节点发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给「加锁操作」设置一个超时时间（不是对「锁」设置超时时间，而是对「加锁操作」设置超时时间），加锁操作的超时时间需要远远地小于锁的过期时间，一般也就是设置为几十毫秒。</li>
</ul>
</li>
<li>第三步是，一旦客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁，就再次获取当前时间（t2），然后计算计算整个加锁过程的总耗时（t2-t1）。如果 t2-t1 &lt; 锁的过期时间，此时，认为客户端加锁成功，否则认为加锁失败。</li>
</ul>
<p>可以看到，加锁成功要同时满足两个条件（<em>简述：如果有超过半数的 Redis 节点成功的获取到了锁，并且总耗时没有超过锁的有效时间，那么就是加锁成功</em>）：</p>
<ul>
<li>条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 节点上成功获取到了锁；</li>
<li>条件二：客户端从大多数节点获取锁的总耗时（t2-t1）小于锁设置的过期时间。</li>
</ul>
<p>加锁成功后，客户端需要重新计算这把锁的有效时间，计算的结果是「锁最初设置的过期时间」减去「客户端从大多数节点获取锁的总耗时（t2-t1）」。如果计算的结果已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p>
<p>加锁失败后，客户端向<strong>所有 Redis 节点发起释放锁的操作</strong>，释放锁的操作和在单节点上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。</p>
<h3 id="5-缓存穿透雪崩的解决方案">5. 缓存穿透、雪崩的解决方案<a hidden class="anchor" aria-hidden="true" href="#5-缓存穿透雪崩的解决方案">#</a></h3>
<p>缓存穿透：同一时刻大量请求访问不存在的数据。</p>
<ul>
<li>缓存空值：可以在缓存中缓存空值来防止压力给到mysql。但是这也不是万能的。缓存空值会浪费我们的空间，如果缓存的空值比较多。还会影响redis的命中率。淘汰了我们正常的热点数据。所以生产环境，我们需要监控一些null空值的数量。避免浪费空间和对正常热数据的影响。我们还可以使用布隆过滤器来处理。</li>
<li>布隆过滤器：查询布隆过滤器，判断数据是否存在。
<ul>
<li>用法：存储数据时，布隆过滤器会先以hash函数来判断数据的落位bit，以bit位0,1来标示数据是否存在。读取数据时，就可以根据0，1判断是否数据是否存在，而不用去缓存和数据库查找数据。</li>
<li>缺点：1.有hash函数就有hash碰撞，所以就有可能将并不在集合中的元素判断在里面。2.不支持删除元素</li>
<li>解决方案：针对第一点，可以采用多个hash函数来确定bit位，减少误差。多个hash都是1的时候，数据真正存在。(存在疑问？多个hash函数不是更加加大了碰撞的几率嘛。确实是这样的。但是前期数据量比较少的时候，多个hash函数可以显著增加误判率，但是随着越来越多的“1”被占用。碰撞的几率也会越来越大。所以需要去关注布隆过滤器的负载量)</li>
<li>另外布隆过滤器有误判的可能。布隆过滤器判断存在数据存在时，不一定存在(因为hash碰撞占位)。数据不存在时，肯定是不存在，这个是准确的。</li>
</ul>
</li>
</ul>
<p>缓存雪崩：有大量的key在同一时间过期，或者redis故障</p>
<ul>
<li>分散key的失效时间。设置过期时间时，可以加一个时间偏移量</li>
<li>设置key不过期。这个方式比较暴力。但是key并不是真正的会一直存在。redis的多种内存淘汰机制可能会清理掉数据。因此我们需要其他的机制来监控缓存的数据。
<ol>
<li>可以将缓存更新的任务交由后台线程完成。定时扫描key是否存在。是否需要更新最新数据。业务不负责缓存数据的更新。但是定时扫描的定时需要trade-off，均衡业务的容忍度。</li>
<li>业务请求时发现数据不存在，往mq中写一条消息。交由消费者完成数据的更新和加载。当然执行前可以检测下，数据是否已经存在。</li>
</ol>
</li>
<li>互斥锁。保证不会有大量的请求打到mysql。只有一个请求完成cache aside方式的数据回写。</li>
</ul>
<p>缓存击穿：热点key数据过期</p>
<ul>
<li>互斥锁</li>
<li>任务key不过期</li>
</ul>
<h3 id="6-如何保证缓存-db一致性">6. 如何保证缓存-db一致性<a hidden class="anchor" aria-hidden="true" href="#6-如何保证缓存-db一致性">#</a></h3>
<ul>
<li>cache aside方式。选择先更新db，再删除缓存。另外可加消费mysql binlog 的方式或者后台任务。保证更新db和删除操作都执行成功。</li>
</ul>
<h3 id="7-redis怎么做限流">7. redis怎么做限流<a hidden class="anchor" aria-hidden="true" href="#7-redis怎么做限流">#</a></h3>
<p>可以依赖redis单线程和其支持的数据结构完成限流操作。例如：依赖list结构实现令牌桶，固定时间生成token，当令牌token为空时，新来的请求阻塞或者直接返回失败。下面是go-zero框架lua脚本实现令牌桶的方式：</p>
<div class="highlight"><div style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f">33
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span>script <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">local</span> rate <span style="color:#f92672">=</span> tonumber(ARGV[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> capacity <span style="color:#f92672">=</span> tonumber(ARGV[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> now <span style="color:#f92672">=</span> tonumber(ARGV[<span style="color:#ae81ff">3</span>])
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> requested <span style="color:#f92672">=</span> tonumber(ARGV[<span style="color:#ae81ff">4</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">过期到下次填充前的时间</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> fill_time <span style="color:#f92672">=</span> capacity<span style="color:#f92672">/</span>rate
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> ttl <span style="color:#f92672">=</span> math.floor(fill_time<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> last_tokens <span style="color:#f92672">=</span> tonumber(redis.call(<span style="color:#e6db74">&#34;get&#34;</span>, KEYS[<span style="color:#ae81ff">1</span>]))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> last_tokens <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    last_tokens <span style="color:#f92672">=</span> capacity
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> last_refreshed <span style="color:#f92672">=</span> tonumber(redis.call(<span style="color:#e6db74">&#34;get&#34;</span>, KEYS[<span style="color:#ae81ff">2</span>]))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> last_refreshed <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    last_refreshed <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">计算上次更新</span>token<span style="color:#960050;background-color:#1e0010">的时间差，计算出需要补多少</span>token<span style="color:#960050;background-color:#1e0010">。判断是否满足请求需要的</span>request
</span></span><span style="display:flex;"><span><span style="color:#f92672">//</span><span style="color:#960050;background-color:#1e0010">计算剩余的</span>token<span style="color:#960050;background-color:#1e0010">量</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> delta <span style="color:#f92672">=</span> math.max(<span style="color:#ae81ff">0</span>, now<span style="color:#f92672">-</span>last_refreshed)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> filled_tokens <span style="color:#f92672">=</span> math.min(capacity, last_tokens<span style="color:#f92672">+</span>(delta<span style="color:#f92672">*</span>rate))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> allowed <span style="color:#f92672">=</span> filled_tokens <span style="color:#f92672">&gt;=</span> requested
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">local</span> new_tokens <span style="color:#f92672">=</span> filled_tokens
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> allowed <span style="color:#66d9ef">then</span>
</span></span><span style="display:flex;"><span>    new_tokens <span style="color:#f92672">=</span> filled_tokens <span style="color:#f92672">-</span> requested
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>redis.call(<span style="color:#e6db74">&#34;setex&#34;</span>, KEYS[<span style="color:#ae81ff">1</span>], ttl, new_tokens)
</span></span><span style="display:flex;"><span>redis.call(<span style="color:#e6db74">&#34;setex&#34;</span>, KEYS[<span style="color:#ae81ff">2</span>], ttl, now)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> allowed<span style="color:#960050;background-color:#1e0010">`</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="8-redis中server和client通信方式">8. redis中server和client通信方式？<a hidden class="anchor" aria-hidden="true" href="#8-redis中server和client通信方式">#</a></h3>
<ul>
<li>简单文本通信协议</li>
</ul>
<h3 id="9-redis淘汰策略">9. redis淘汰策略<a hidden class="anchor" aria-hidden="true" href="#9-redis淘汰策略">#</a></h3>
<ul>
<li>noeviction（不淘汰策略）：当内存不足以容纳新写入数据时，新写入操作会报错&quot;OOM（Out of Memory）&quot;。默认情况下，Redis就采用了此种淘汰策略。</li>
<li>allkeys-lru（最近最少使用淘汰策略）：Redis会根据键的最近最少使用时间来淘汰数据。当内存不足以容纳新写入数据时，从所有键中选择最近最少使用的数据淘汰。</li>
<li>volatile-lru（设置过期时间的最近最少使用淘汰策略）：Redis会根据键的最近最少使用时间来淘汰键值对，但只会针对设定了过期时间的键值对进行淘汰。</li>
<li>volatile-ttl（设置过期时间淘汰策略）：Redis会根据键值对的剩余存活时间来淘汰数据。当内存不足以容纳新写入数据时，优先淘汰存活时间较短的数据。此种淘汰策略适用于只关心最近活跃数据的场景。</li>
</ul>
<h3 id="10-缓存预热如何做">10. 缓存预热？如何做？<a hidden class="anchor" aria-hidden="true" href="#10-缓存预热如何做">#</a></h3>
<pre><code>缓存预热：redis启动前缓存热门数据

nginx+lua将流量请求打到kafka中，让kafka抗高并发的量。然后数据写入storm中，storm完成M份Top N数据的生成。然后聚合生成热门数据存到zk中，新起任务完成读取数据，写入redis。完成预热缓存。
</code></pre>
<h3 id="11-redis-应用题-设计一个每日日活用户统计功能">11. Redis 应用题: 设计一个每日日活用户统计功能<a hidden class="anchor" aria-hidden="true" href="#11-redis-应用题-设计一个每日日活用户统计功能">#</a></h3>
<pre><code>需求: 我们的网站每天用户访问之后，UserID 将会被收集到我们的 Redis 数据存储（需要你思考如何存储），我们的后台需要支持一个功能:
1.API - 支持查询 某一天访问的用户 &amp; 前一天并没有访问我们的网站
Request : {&quot;date&quot;: &quot;20230216&quot;}
Response: {&quot;user_ids&quot;: [1,3,4]}
2.API 拓展 - 在支持(1) 的基础上，支持根据指定批量日期范围查询这个数据
Request : {&quot;dates&quot;: [&quot;20230216&quot;, &quot;20230217&quot;]}
Response: {&quot;list&quot;: [{&quot;date&quot;: &quot;20230216&quot;, &quot;user_ids&quot;: [1,3,4]}, {&quot;date&quot;: &quot;20230216&quot;, &quot;user_ids&quot;: [2,9]}]}
数据量级:
Level0: 每日访问用户数在 1K 以内
Level1: 每日访问用户数在 10K 以内
考察点1: redis 数据存储如何设计，应该使用什么数据结构，怎么记录和实现功能

答案：
1.按照天的维度将用户放到set结构中(key是日期，value是UserID)，针对查询需求，可以将两天的set做diff操作，生成到一个new set中。
2.如果要支持指定批量日期范围查询，首先需要明确最早日期，日期数量是否有限制？qps是多少(每条执行多少请求和计算量有关)，如果不高的话，可以实时diff计算，
一般情况下，latency会比较长。
latency过长的解决方案：
1.缓存：new set已经放入到了redis中，如果请求中的日期过多，影响了latency的性能，那么可以使用进程内缓存，此时就要考虑缓存的大小如何设计？(设计的标准应该是满足当前qps，多少数据从redis拿，多少从进程缓存拿，可以满足qps需求)，考虑设计缓存淘汰方式(LRU、LFU or 其他？，这里选择LFU，淘汰使用频率最少的比较合理)。
2.升级机器配置，升级cpu配置，升级redis配置。使得机器cpu不是瓶颈(内存应该不是瓶颈，不需要考虑)，升级redis的cpu配置，主从或者分片。

数量级问题需要注意的点：1k以内的set，userid是int类型的话8byte，一个日期的key存储占8k(set是hash结构和intset，那就按照正常的数组大小评估，就是8k)，不算是大key(大key的标准和结构中的数量和元素的大小相关)，那么diff完成的也不是大key。这个时候就还是考虑latency的问题了，按照上面方案解决就行。

如果真的数量级到了大key，那么一般方案也就是拆分成多个key，此时内存友好，但是cpu就不友好了。解决的话，可以升级配置。或者redis集群部署，分散压力。
</code></pre>
<h3 id="12-redis的主从同步流程">12. Redis的主从同步流程<a hidden class="anchor" aria-hidden="true" href="#12-redis的主从同步流程">#</a></h3>
<ul>
<li>全量同步：
<ul>
<li>触发条件：首次同步，master节点进程id发生变化，master缓存中没有slave当前同步的offsetID(滞后太多)</li>
<li>同步过程：
<ol>
<li>slave向master发起链接建立。</li>
<li>slave向master发起sync命令，请求复制数据</li>
<li>master收到PSYNC命令后，会在后台进行数据持久化；
<ul>
<li>通过bgsave生成最新的rdb快照文件</li>
<li>bgsave期间，将客户端发送的命令（会修改数据集的）缓存到内存中；</li>
</ul>
</li>
<li>持久化完毕后，master将这份RDB数据发送给slave；</li>
<li>slave会把接收到的数据进行持久化生成RDB，然后再加载到内存中。</li>
<li>master继续将之前缓存在内存中的命令通过socket发送给slave。</li>
</ol>
</li>
</ul>
</li>
<li>增量，断点续传同步：
<ul>
<li>同步过程：
<ol>
<li>断开重连后，slave向master发送psync命令同步数据</li>
<li>master会在内存中维护命令队列repl backlong buff，并且master拥有各slave的数据下标offset，slave有master进程id</li>
<li>重连后，从下标开始接受master缓冲队列的命令，完成同步</li>
<li>如果master进程节点id变化，或者从节点数据下标offset太久，已经不在master的缓存队列里，则会进行一次全量数据复制</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>注意点：</p>
<ol>
<li>主从复制时，如果有过多的从节点，为了缓解主从复制风暴，多个从节点同事复制主节点导致主节点压力过大。可以让部分从节点作为假主，关联其他从库。也就是主-从(假主)-从</li>
<li>RDB用于全量复制，全量复制完后，后续的执行指令，master会将repl backlong buff中缓存的指令通过socket发送给从库。</li>
<li>主从复制的时候，针对slave进行全量数据同步，slave在加载master的RDB文件前，会运行flushall来清理自己当前的数据。slave-lazy-flush参数设置决定是否采用异步flush的机制。异步flush清空从节点本地数据库，可减少全量同步耗时，从而减少主库因输出缓冲区爆炸引起的内存使用增长。</li>
</ol>
<h3 id="13-redis多线程网络io模型下面的内容都来自潘少的bloghttpsstrikefreedomtoparchivesmultiple-threaded-network-model-in-redis">13. Redis多线程网络IO模型(下面的内容都来自潘少的<a href="https://strikefreedom.top/archives/multiple-threaded-network-model-in-redis">blog</a>)<a hidden class="anchor" aria-hidden="true" href="#13-redis多线程网络io模型下面的内容都来自潘少的bloghttpsstrikefreedomtoparchivesmultiple-threaded-network-model-in-redis">#</a></h3>
<ol>
<li>redis为什么这么快？
<ul>
<li>C语言支持</li>
<li>内存型数据库</li>
<li>网络IO多路复用</li>
<li>单线程模型，避免多线程频繁上下文切换，额外的同步机制</li>
<li>高性能的数据结构设计</li>
</ul>
</li>
<li>redis为什么选择单线程
<ul>
<li>避免过多的上下文切换开销
<ul>
<li>多线程调度必然会有上下文切换的开销，具体的开销在于程序计数器，堆栈指针和程序状态等一系列寄存器置换，程序堆栈重置等，还会影响cpu cache，TLB快表的淘汰置换。单一进程的多线程切换还好一些，因为多个线程共享进程地址空间。对比跨进程(多进程)的调度，那么开销就会很大，需要切换掉整个进程的地址空间。</li>
</ul>
</li>
<li>避免同步机制的开销
<ul>
<li>多线程模型下，势必会有一些同步机制，用来保证数据的状态。简单来说就是需要加锁了。因为redis有丰富的数据类型，此时锁的粒度又会有很多取舍。这样不仅会有锁的开销，程序的复杂度也会极具增长。与redis简单设计的理念不符</li>
</ul>
</li>
</ul>
</li>
<li>redis多线程发展历程
<ul>
<li>redis 4.0的时候引入了多线程处理异步任务。这些任务包括数据清理，数据备份bgsave等。主要的目的避免一些阻塞的命令，影响单线程执行模型。比如新增了UNLINK、FLUSHALL ASYNC等。但网络IO处理还是单线程的。</li>
<li>redis 6.0。
<ul>
<li>Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis（6.0之前 ） 采用的是单 Reactor 单进程的方案。</li>
<li>发展到这个阶段，多线程来提升整体性能已经是必定的路了。因为redis的单线程模型会导致系统消耗很多cpu在网络IO上，从而降低了吞吐量，那么为了解决这个问题，只能1.优化网络IO 2.提高机器内存读写速度。显然完成条件1是首先考虑的。优化1是手段有1.零拷贝 2.利用多核优势。零拷贝无法应对redis这一类复杂的网络IO场景。所以顺理成章的我们需要利用多核优势了。</li>
<li>6.0的时候，增加多线程来处理网络IO的读写，就是多线程去处理IO读写数据，但执行操作还是单线程的。官方的数据显示增加多线程后，性能提升一倍。</li>
</ul>
</li>
</ul>
</li>
<li>cpu亲和性
<ul>
<li>redis6.0后，多线程执行很多异步任务，并发度已经有很大提升，而且redis是对吞吐量和延迟很敏感的系统。故此需要考虑cpu切换时的性能损耗，为了避免这个情况，redis启动的时候设置了cpu亲和性，也就是绑核，将某些线程/进程绑定到固定的cpu上，其他任务就不会占用这些任务的cpu时间片，能更高效率的工作，也能极大限度借助cpu cache提升性能。</li>
</ul>
</li>
<li>free lock的设计
<ul>
<li>引入多线程，不可避免的会有共享资源竞争，就会引出锁来保护共享资源。但是redis通过原子操作和时空交错访问来实现无锁的多线程模型。记住redis6.0的源码中，IO读写多线程只完成读写数据的操作。</li>
<li>下面是多线程读的流程。
<ul>
<li>当有client就绪时，就会将client放入队列clients_pending_read</li>
<li>主线程遍历待读取的client队列，通过 RR 策略把所有任务分配给 I/O 线程和主线程去读取和解析客户端命令。</li>
<li>忙轮询等待所有 I/O 线程完成任务。</li>
<li>完成任务后，再遍历 clients_pending_read，执行所有 client 的命令。</li>
<li>执行完成后，需要回复的内容已经写入每个client的buf中了。然后将client放入clients_pending_write队列中，等待调度，将响应内容返回给客户端。</li>
</ul>
</li>
<li>下面是多线程写的流程：
<ul>
<li>检查当前任务负载，如果当前的任务数量不足以用多线程模式处理的话，则休眠 I/O 线程并且直接同步将响应数据回写到客户端。</li>
<li>唤醒正在休眠的 I/O 线程（如果有的话）。</li>
<li>遍历待写出的 client 队列 clients_pending_write，通过 RR 策略把所有任务分配给 I/O 线程和主线程去将响应数据写回到客户端。</li>
<li>忙轮询等待所有 I/O 线程完成任务。</li>
<li>最后再遍历 clients_pending_write，为那些还残留有响应数据的 client 注册命令回复处理器 sendReplyToClient，等待客户端可写之后在事件循环中继续回写残余的响应数据。</li>
</ul>
</li>
<li>为什么是lock free呢？
<ul>
<li>主线程和 I/O 线程之间共享的变量有三个：io_threads_pending 计数器、io_threads_op I/O 标识符和 io_threads_list 线程本地任务队列。io_threads_pending 是原子变量，不需要加锁保护，io_threads_op 和 io_threads_list 这两个变量则是通过控制主线程和 I/O 线程交错访问来规避共享数据竞争问题：I/O 线程启动之后会通过忙轮询和锁休眠等待主线程的信号，在这之前它不会去访问自己的本地任务队列 io_threads_list[id]，而主线程会在分配完所有任务到各个 I/O 线程的本地队列之后才去唤醒 I/O 线程开始工作，并且主线程之后在 I/O 线程运行期间只会访问自己的本地任务队列 io_threads_list[0] 而不会再去访问 I/O 线程的本地队列，这也就保证了主线程永远会在 I/O 线程之前访问 io_threads_list 并且之后不再访问，保证了交错访问。io_threads_op 同理，主线程会在唤醒 I/O 线程之前先设置好 io_threads_op 的值，并且在 I/O 线程运行期间不会再去访问这个变量。</li>
</ul>
</li>
</ul>
</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.youngergo.cn/en/tags/redis/">redis</a></li>
      <li><a href="https://www.youngergo.cn/en/tags/interview/">interview</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://www.youngergo.cn/en/posts/tech/go-%E7%9F%A5%E8%AF%86%E7%82%B9/">
    <span class="title">Next »</span>
    <br>
    <span>Go 知识点</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://www.youngergo.cn/en/">Younger&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
